# 程序员计算器的设计与实现

## 1. 设计目的

通过设计、编制、调试一个支持算术、逻辑及移位运算的程序员计算器，深入理解编译器的词法分析、语法分析、错误处理及输出等核心环节。本项目旨在通过实践，获得对编译器构造原理、过程和方法的感性认识，并系统地掌握语法制导翻译技术。

## 2. 设计内容

* **基本要求**: 采用语法制导翻译模式，设计一个能够支持基本算术（加减乘除）、逻辑运算（按位与、或）以及不同进制（十、十六、二）输入的编译器。
* **扩展要求**: 在基本要求之上，增加对移位运算（左移、右移）的支持。

---

## 3. 项目架构与编译

本项目采用 C++ 17 标准，并遵循模块化的设计思想，将编译器前端的核心功能解耦到不同的模块中，以提升代码的可读性、可维护性和可重用性。

* **文件结构**:
  * `lexer.h / lexer.cpp`: **词法分析器模块**，负责将输入的表达式字符串转换为 Token 序列。
  * `parser.h / parser.cpp`: **语法分析器模块**，是编译器的核心，负责语法分析、语义分析及中间代码生成/即时求值。
  * `colors.h`: **终端颜色模块**，用于美化控制台输出，提升用户交互体验。
  * `main.cpp`: **主程序入口**，作为驱动程序，提供交互式菜单，整合并调用其他模块。
  * `.vscode/`: 包含了 `tasks.json` 和 `launch.json`，为 Visual Studio Code 提供了针对多文件项目的编译和调试配置。

```text
CompilerPrinciple/
├── .vscode/                 # VS Code 配置文件夹
│   ├── c_cpp_properties.json
│   ├── launch.json
|   ├── setting.json
│   └── tasks.json
├── output/                  # 用于存放最终产出的文件夹(.exe .sym .tac)
├── tests/                   # 用于存放测试用例的文件夹
│   ├── batch1.txt           # 测试文件
|   └── batch2.txt           # 测试文件
├── colors.h                 # 终端颜色模块
├── lexer.cpp                # 词法分析器实现
├── lexer.h                  # 词法分析器接口
├── calculator.cpp           # 主程序入口
├── parser.cpp               # 语法分析器实现
└── parser.h                 # 语法分析器接口
```

* **编译命令**:

```bash
g++ -std=c++17 main.cpp lexer.cpp parser.cpp -o calculator
```

---

## 4. 编译器模块化设计

### 4.1. 词法分析器 `Lexer`

词法分析器是编译过程的第一步，它的任务是将原始的文本字符串分解成一个个有意义的、标准化的单元，即“词法记号”(Token)。

1. **Token 类型定义**:
    * `TokenType` 枚举类：使用了 C++11 引入的 `enum class` 来定义所有可能的 Token 类型（如 `INTEGER`, `PLUS`, `LSHIFT` 等）。这是一种强类型枚举，可以避免与全局命名空间中的宏（如`EOF`）产生命名冲突，代码更安全、更清晰。
2. **Token 结构体**:
    * `struct Token` 包含了 `type` (该词法记号的类型) 和 `value` (该词法记号的属性值) 两个核心字段。
    * 通过友元函数重载了 `<<` 操作符，使得 `Token` 对象可以被 `std::cout` 直接打印，极大地便利了调试过程。
3. **多进制支持**: `get_number()` 方法能够智能识别 `0x` 和 `0b` 前缀，从而支持十六进制和二进制整数的输入，并将它们统一转换为标准的 `int` 类型供上层使用。
4. **性能优化**: `Lexer` 的构造函数采用了**移动语义 (Move Semantics)** `std::move(text)` 来初始化其内部的字符串成员。 这避免了对可能很长的输入表达式进行昂贵的深拷贝操作，而是通过“窃取”其资源的方式高效地完成初始化。

### 4.2. 解析器 `Parser`

解析器是编译器的核心大脑。本项目的设计完美体现了**语法制导翻译 (Syntax-Directed Translation, SDT)** 的思想，并基于经典的**递归下降分析法 (Recursive Descent Parsing)** 构建。

#### 4.2.1. 核心方法：递归下降与运算符优先级

1. **运算符优先级**: 本计算器支持的运算符优先级关系如下，通过函数调用链的层次结构严格实现：
    `()` (括号) > `+ -` (一元) > `* /` > `+ -` (二元) > `<< >>` > `&` > `|` (最低)
2. **产生式与函数映射**:
    * **非终结符 -> 函数**: 文法中的每一个非终结符（如 `add_expr`, `factor`）都精确地映射为 `Parser` 类中的一个私有方法。
    * **产生式规则 -> 函数体**: 每个方法内部的逻辑严格实现了对应非终结符的 EBNF 产生式规则。
    * **优先级 -> 函数调用链**: `A` 的优先级高于 `B`，在代码中就体现为 `B()` 函数的实现中调用了 `A()` 函数。例如，`add_expr()` 必须调用 `mul_expr()` 来获取操作数，这就保证了乘法一定优先于加法。

#### 4.2.2. 核心技术：语法制导翻译 (Syntax-Directed Translation)

本项目全面并深入地应用了**语法制导翻译**技术。其核心在于，在进行递归下降语法分析的同时，为每条文法产生式规则附加了相应的**语义动作 (Semantic Action)**。通过 `ParseMode` 开关，本项目更是为同一套文法规则实现了两种不同的语义动作，清晰地展示了 SDT 的灵活性和强大功能：

1. **解释器模式 (`INTERPRET` mode) - 语法制导求值**:
    * **语义动作**: **立即进行数值计算**。
    * **核心机制**: 当语法分析器匹配一个运算规则（如 `mul_expr '+' mul_expr`）时，附带的语义动作是立即执行 C++ 的 `+` 运算得出结果。所有解析函数统一返回 `std::string` 作为临时结果的“代号”（如`t1`），并使用内部的 `map` 成员 `temp_values_` 作为“草稿本”，将代号与其真实的 `int` 型计算结果关联起来。返回的 `string` 是一个**键 (key)**，用于在这个“草稿本”中存取中间计算结果。

2. **编译器模式 (`COMPILE` mode) - 语法制导生成中间代码**:
    * **语义动作**: **生成中间表示 (Intermediate Representation)**。
    * **核心机制**: 当语法分析器匹配同一运算规则时，它执行一个完全不同的语义动作：**不进行计算**，而是将表达式翻译成等价的**三地址码**，并构建**符号表**。解析函数返回的 `std::string` 在此模式下只是一个**名字 (name)**，被用作下一条生成的三地址码指令的**操作数 (operand)**。
    * **产出**:
        * **三地址码 (Three-Address Code)**: 生成的指令（如 `t2 = t0 * t1`）被存储在 `intermediate_code_` 向量中。
        * **符号表 (Symbol Table)**: 每当创建新的临时变量（如`t0`）时，其名称和类型（`int`）会被注册到 `symbol_table_` 中。

通过这种双模式设计，本项目以一个统一的框架，同时实现了解释器和编译器前端这两个在编译原理中至关重要的角色。

#### 4.2.3. 代码复用：`binary_op_parser` 函数模板

为了避免在 `add_expr`, `mul_expr`, `shift_expr` 等函数中重复编写几乎完全相同的 `while` 循环逻辑，本项目设计了一个通用的私有成员函数模板 `binary_op_parser`。

* **`template<typename Func>`**: 使该函数可以接收任意类型的可调用对象（`lambda`函数）。
* **成员函数指针 `std::string (Parser::*next_level_func)()`**: 作为一个“插座”，接收下一层级（更高优先级）解析函数的地址，实现了调用逻辑的泛化。
* **`lambda` 函数作为操作**: 允许在调用时，动态地传入具体的运算逻辑（如加法、乘法等）。

通过这个高度抽象的模板，极大地提升了代码的复用性和可维护性。

---

## 5. 错误处理与输出

1. **错误处理**:
    * **词法错误**: 在 `Lexer` 中，当遇到无法识别的非法字符时，会抛出 `std::runtime_error` 异常，并附带错误字符和其所在位置。
    * **语法错误**: 在 `Parser` 中，当 `Token` 序列不符合文法规则时（如括号不匹配、缺少操作数），会抛出包含预期和实际 `Token` 信息的异常。
    * **语义错误**: 在解释器模式下，对“除零”等运行时错误进行检查并抛出异常。

2. **输出与交互**:
    * **菜单驱动**: `main` 函数提供了一个清晰的、带有颜色高亮的交互式菜单，引导用户选择工作模式。
    * **自动化测试框架 (双模式)**:
        * 在解释器模式下，提供了一个读取测试文件并自动评测的强大框架。该框架的核心特性在于其**双模式工作机制**：
        * **自我测评模式**: 当测试文件中的某一行包含特殊标记 `// expect: <结果>` 或 `// expect: error` 时，该行被视为一个**测试断言 (Assertion)**。程序会严格比对实际运行结果与期望结果是否一致，并将此案例计入最终的**通过/失败统计**。
        * **普通计算器模式**: 如果某一行是合法的表达式，但**不包含** `// expect:` 标记，程序则将其作为普通的计算任务处理。它会直接计算并输出结果，但**不会**将其纳入最终的通过率统计范畴。
        * 这种设计极大地提升了测试文件的灵活性，使其既能作为严肃的测试套件，又能作为临时的批量计算草稿本。
    * **结构化文件输出**: 在编译器模式下，程序将所有表达式的编译结果（三地址码和符号表）统一输出到 `output/` 目录下的两个文件中（`.tac` 和 `.sym`），并用清晰的分隔符区分，避免了文件泛滥，使产出整洁、专业。

## 6. 项目总结

本项目成功地从零开始，使用 C++ 设计并实现了一个功能完备的程序员计算器。通过模块化的分层设计，清晰地划分了词法分析与语法分析的职责。在核心的语法分析模块，不仅实现了经典的递归下降算法，更通过语法制导翻译技术，创新性地设计了“解释/编译”双工作模式，并通过模板元编程等技巧优化了代码结构。最终的成品不仅满足了所有的设计要求，还包含了自动化测试、彩色终端交互、结构化文件输出等高质量的扩展功能，完整地模拟了现代编译器前端的工作流。
