# 函数调用与栈帧分析详解

本笔记详细分析一个C语言递归函数调用时，其在x86架构下的汇编代码如何操作栈帧。

---

## 源代码与汇编代码

### C语言源代码

```c
void func(long i) {
    long j;
    j = i - 1;
    func(j);
}
```

### X86汇编代码

```asm
func:
    pushl %ebp
    movl %esp, %ebp
    subl $4, %esp
    
    movl 8(%ebp), %edx
    decl %edx
    movl %edx, -4(%ebp)
    
    movl -4(%ebp), %eax
    pushl %eax
    call func
    
    addl $4, %esp  // This line is technically part of the caller's cleanup
                  // but is shown here for context. It's jumped over by 'call'.
.L1:
    leave
    ret
```

## 函数调用的初始准备

在执行 `func` 函数内的第一条汇编指令之前，调用者 (Caller) 和 CPU 硬件 已经完成了准备工作。

1. 调用者压入参数：调用者的代码执行 `pushl i`，将参数 `i` 压入栈。
2. `call` 指令执行：CPU 执行 `call func` 指令，硬件自动将返回地址压入栈，并跳转到 func 的第一行。

此刻的“初始状态”栈帧：

```txt
      高地址
      | ...          |
      +--------------+
      |  参数 i       | <-- 调用者压入
      +--------------+
esp ->|  返回地址     | <-- 'call'指令压入
      +--------------+
      | ...          |
      低地址
```

## 逐句分析与栈帧变化

### 建立新栈帧

这两条指令是函数序言（prologue）的标准操作，用于建立被调用者（Callee）自己的栈帧。

`pushl %ebp`

作用：保存调用者的`%ebp`值（旧的基址指针），以便函数返回时可以恢复。

栈帧变化：

```txt
      高地址
      | ...          |
      +--------------+
      |  参数 i       |
      +--------------+
      |  返回地址     |
      +--------------+
esp ->|  旧的%ebp值   |  <-- %ebp 后续将指向这里
      +--------------+
      | ...          |
      低地址
```

`movl %esp, %ebp`

作用：将当前栈顶指针`%esp`的值赋给`%ebp`。从此，`%ebp`成为当前新栈帧的固定基址，用于稳定地访问局部变量和参数。

栈帧变化：

```txt
         高地址
         | ...          |
         +--------------+
         |  参数 i       |  <-- 8(%ebp)
         +--------------+
         |  返回地址    |  <-- 4(%ebp)
         +--------------+
ebp,esp->|  旧的%ebp值   |  <-- 0(%ebp)
         +--------------+
         | ...          |
         低地址
```

## 为局部变量分配空间

`subl $4, %esp`

作用：将栈顶指针`%esp`向下移动`4`字节（`long`类型的大小），为局部变量`j`预留空间。

栈帧变化：

```text
      高地址
      | ...          |
      +--------------+
      |  参数 i       |  <-- 8(%ebp)
      +--------------+
      |  返回地址    |  <-- 4(%ebp)
      +--------------+
ebp ->|  旧的%ebp值   |  <-- 0(%ebp)
      +--------------+
esp ->| 局部变量 j   |  <-- -4(%ebp)
      +--------------+
      | ...          |
      低地址  
```

### 执行函数体 (j = i - 1)

`movl 8(%ebp), %edx`

作用：从栈中读取参数 `i`（位于 `%ebp` 向上`8`字节处），存入 `%edx` 寄存器。

`decl %edx`

作用：将 `%edx` 寄存器的值减`1`，完成 `i-1` 的计算。

`movl %edx, -4(%ebp)`

作用：将计算结果 `i-1` 从 `%edx` 存入为局部变量 `j` 分配的栈空间中（位于 `%ebp` 向下4字节处）。

### 准备下一次递归调用 (func(j))

`movl -4(%ebp), %eax`

作用：将局部变量 `j` 的值从栈中加载到 `%eax` 寄存器。`%eax` 常用于传递参数或存放返回值。

`pushl %eax`

作用：将即将传递的参数 `j` 的值压入栈顶，为下一次 `call` 做准备。

栈帧变化：

```txt
      高地址
      | ...          |
      +--------------+
ebp ->|  旧的%ebp值   |  <-- 0(%ebp)
      +--------------+
      | 局部变量 j   |
      +--------------+
esp ->|  参数 j (i-1) |  <-- 为下一次调用准备的新参数
      +--------------+
      | ...          |
      低地址
```

`call func`

作用：硬件自动压入新的返回地址，并跳转到`func`开头，开始新一轮的递归。

`addl $4, %esp`

作用：当递归调用返回后，执行此句。将`%esp`向上移动`4`字节，清理掉之前为递归调用压入的参数`j`。

### 销毁栈帧并返回

当递归调用返回后，会执行到 `.L1` 标签后的指令。

`leave`

作用：函数尾声（epilogue）的标准指令，自动完成两步操作：**感觉这里是恢复原先的帧栈状态**

1. `movl %ebp, %esp`：释放整个栈帧，将栈顶指针恢复到栈底。
2. `popl %ebp`：恢复调用者的`%ebp`，使`%ebp`指回上一层栈帧的基址。

`ret`

作用：弹出栈顶的返回地址，并跳转到该地址，将控制权交还给调用者。**感觉这里是返回原先的代码断点处**

1. 弹出返回地址 (Pop Return Address)：
CPU硬件会假定，当前栈顶指针 `%esp` 所指向的位置，存放着一个地址。这个地址就是当初 `call` 指令压入栈中的返回地址（即调用函数的下一条指令的地址）。
`ret` 指令会把这个地址从栈中弹出到一个CPU内部的、程序员不可见的寄存器中，同时 `%esp` 指针会向上移动`4`个字节（在32位系统中）。
2. 跳转到返回地址 (Jump to Return Address)：
CPU会立即无条件地跳转到刚刚弹出的那个地址去执行。
这样一来，程序的控制权就从被调用的函数，顺利地交还给了调用者，程序可以从它上次离开的地方继续往下执行。

## 拓展

尽管代码中不考虑递归终点，但是可以浅显分析一下，如下是开始进行 **最后一次递归** `call func` 前夕的栈帧状态

```txt
      高地址
      | ...          |
      +--------------+
ebp ->|  旧的%ebp值   |  <-- 0(%ebp)
      +--------------+
      | 局部变量 j   |
      +--------------+
esp ->|  参数 j (i-1) |  <-- 为最后一次 func 调用准备的新参数
      +--------------+
      | ...          |
      低地址
```

最后一次 `call func` 的执行过程，`addl $4, %ebp` 指令执行之前的栈帧状态如下：

```txt
      高地址
      | ...          |
      +--------------+
      |  旧的%ebp值   |
      +--------------+
      | 局部变量 j   |
      +--------------+
      |  参数 j (i-1) |  <-- 为最后一次 func 调用准备的新参数
      +--------------+
      |  返回地址      |  <-- 最后一次 call func 所压入的返回地址
      +--------------+
ebp ->|  旧的%ebp值   |
      +--------------+
esp ->|局部变量j'(j-1) |  <-- 递归边界，不在进行后续的递归操作
      +--------------+
      | ...          |
      低地址
```

执行 `addl $4, %ebp` 后的栈帧状态如下：

```txt
          高地址
          | ...          |
          +--------------+
          |  旧的%ebp值   |
          +--------------+
          | 局部变量 j   |
          +--------------+
          |  参数 j (i-1) |  <-- 为最后一次 func 调用准备的新参数
          +--------------+
          |  返回地址      |  <-- 最后一次 call func 所压入的返回地址
          +--------------+
ebp,esp ->|  旧的%ebp值   |
          +--------------+
          | ...          |
          低地址
```

`leave` 指令执行后的栈帧状态如下：

```txt
          高地址
          | ...          |
          +--------------+
    ebp ->|  旧的%ebp值   |
          +--------------+
          | 局部变量 j   |
          +--------------+
          |  参数 j (i-1) |  <-- 为最后一次 func 调用准备的新参数
          +--------------+
    esp ->|  返回地址      |  <-- 最后一次 call func 所压入的返回地址
          +--------------+
          | ...          |
          低地址
```

`ret` 指令执行后的栈帧状态如下：

可以清晰的看出此时的帧栈状态已经完好的恢复至开始进行 **最后一次递归** `call func` 前夕的栈帧状态

```txt
          高地址
          | ...          |
          +--------------+
    ebp ->|  旧的%ebp值   |
          +--------------+
          | 局部变量 j   |
          +--------------+
    esp ->|  参数 j (i-1) |  <-- 为最后一次 func 调用准备的新参数
          +--------------+
          | ...          |
          低地址
```
