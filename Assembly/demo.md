## 指令分析1
```asm
wNum DW 8004H
mov ax, 5
mul wNum
mov ax, 5
imul wNum
```
- 现代计算机几乎使用**补码**进行存储和处理数据, wNum 指向的存储空间中的值为 `8004H`, 该数便是一个补码(KEY)
- **反码**的两种情况:
  - 对于**无**符号数: 反码就是对每一位进行取反操作
  - 对于**有**符号数: 正数的反码与原码相同; 负数的反码符号位保持不变, 数值位均进行取反操作
- 补码扩展时, 使用符号位进行扩展

### 针对 `mov ax 5 : imul wNum` 指令的分析如下:
- `imul` 指令用于有符号数的乘法运算, `8004H` 的最高位为 `1`, 所以在 `imul` 指令看来, 该数是一个负数补码
- 负数补码进行先全部取反, 后加一的操作, 将得到该负数的绝对值
- `8004H` 的二进制表示为 `1000 0000 0000 0100`, 全部取反操作结果为 `0111 1111 1111 1011` 即 `7FFBH`, 加一操作变为 `7FFCH`, `7FFCH` 转化为十进制为 `32764`, 所以该负数的十进制表示为 `-32764`
- 十进制运算下, `-32764 * 5` 的结果为 `-163820`
- 十进制 `163820` 转化为二进制为 `0010 0111 1111 1110 1100`(原码), 十进制 `-163820` 转化为二进制原码为 `1 0010 0111 1111 1110 1100`(原码), 补码运算可得 `1 1101 1000 0000 0001 0100`(补码), 补码扩展到 32 位可得 `1111 1111 1111 1101 1000 0000 0001 0100`(扩展后的补码)
- 前 16 位存储在 `DX` 中, 后 16 位存储在 `AX` 中
- `DX` 中存储的是 `0FFFDH`, `AX` 中存储的是 `8014H`

### 针对 `mov ax 5 : mul wNum` 指令的分析如下:
- `mul` 指令用于无符号数的乘法运算
- 对 `8004H` 中的每一个数值进行十进制下的乘 `5` 操作, 结果值每满 `16` 进 `1`
- `DX` 中存储的是 `0002H`, `AX` 中存储的是 `8014H`

